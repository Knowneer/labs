/*

1.
Рекурсия — это когда функция вызывает саму себя, чтобы решить задачу через более простой/меньший подслучай.
Рекурсивная функция отличается тем, что у неё есть:
рекурсивный шаг (переход к меньшей задаче)
базовый случай (условие остановки)

Базовый случай — это ситуация, когда ответ уже известен без дальнейших вызовов функции
Если забыть базовый случай или сделать так, что до него нельзя дойти:
функция будет вызываться бесконечно,
стек вызовов будет расти,
будет stack overflow (переполнение стека) → аварийное завершение.

2.
Стек вызовов — область памяти, где хранятся кадры  активных функций:

адрес возврата (куда вернуться после return)
локальные переменные
параметров функции (параметры - это тоже локальные переменные передаваемые при вызове)

Потому что стек ограничен по размеру. При глубокой рекурсии создаётся много кадров - память под стек заканчивается

3.

Цикл — это когда ты сам руками контролируешь повторение
(for, while)
Рекурсия — это когда функция сама себя вызывает, и повторение происходит через вызовы функций


цикл, когда:
ты просто повторяешь одно и то же действие n раз
идёшь по массиву слева направо
считаешь сумму, максимум, минимум
количество шагов понятно заранее


рекурсию когда:
задача естественно делится на такую же, но меньшую
каждый шаг — это та же задача, но проще
результат следующего шага зависит от предыдущего

5.
Фибоначчи:
F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2).

медленная потому что экспоненциальное время O(2^n).
Потому что она повторно вычисляет одни и те же значения.
Например F(5) вызывает F(4) и F(3), а F(4) снова вызывает F(3) и F(2) — F(3) считается много раз

Как улучшить:
Мемоизация (кэшировать уже посчитанные F(k)) - O(n)
Динамика снизу вверх (цикл) - O(n), память O(1)

6.
Временная сложность — как растёт время выполнения при росте размера входа n.
Big-O — верхняя оценка порядка роста (константы и мелкие члены игнорируются).

Примеры:
O(1) — константное: доступ к элементу массива по индексу a[i]
O(log n) — логарифм: при увеличении входных данных в 2 раза, количество операций увеличивается на 1 шаг
для массива- n = количество элементов
для графа- n = количество вершин
для строки- n = длина строки
для файла- n = количество записей




O(n) — линейное: пройти массив, найти максимум
O(n^2) — квадратичное: двойной цикл по массиву (пузырёк/выбор/вставки в худшем)
O(n log n) — типичная “хорошая” сортировка (quick/merge/heap в среднем/гарантии зависят)

7.
Quicksort (разделяй-и-властвуй):
Берём один элемент — он называется pivot (опорный)
Все элементы:
меньше pivot - кидаем влево
больше pivot - кидаем вправо
Потом отдельно сортируем левую и правую части

Худший случай — это когда алгоритм работает максимально долго
Для быстрой сортировки худший случай — когда:
массив уже отсортирован
pivot каждый раз выбирается самый плохой

быстрая потому что
в среднем pivot делит массив нормально
средняя сложность O(n log n)
на практике работает очень быстро


8.
std::sort сортирует диапазон [begin, end) по < или компаратору
Компаратор — это функция, которая говорит, кто меньше
Ей можно доверять: это стандартная библиотека, реализация оптимизирована и протестирована

Свою пишут, если нужны особые условия (например, стабильность - std::stable_sort)


9.
DFS (Depth-First Search) — поиск в глубину: идём “вглубь” насколько можно, потом откатываемся.
Реализация: рекурсия 
BFS (Breadth-First Search) — поиск в ширину: идём слоями по расстоянию.
Реализация: очередьч

10.
Лабиринт можно представить как граф: клетки — вершины, проходы — рёбра.

Способы:

DFS — найдёт путь, если он есть, но не гарантирует кратчайший
можно ли дойти

std::vector<std::vector<int>> graph;
std::vector<bool> visited;

void dfs(int v){
    visited[v] = true; // отмечаем, что были здесь

    for (int to : graph[v])
    {
        if (!visited[to])
        {
            dfs(to); // идём глубже
        }
    }
}




BFS — в лабиринте без весов (каждый шаг = 1) даст кратчайший путь
лабиринты
кратчайший путь
#include <queue>

std::vector<std::vector<int>> graph;
std::vector<bool> visited;

void bfs(int start)
{
    std::queue<int> q;

    visited[start] = true;
    q.push(start);

    while (!q.empty())
    {
        int v = q.front();
        q.pop();

        for (int to : graph[v])
        {
            if (!visited[to])
            {
                visited[to] = true;
                q.push(to);
            }
        }
    }
}




хранение графа 
std::vector<std::vector<int>> graph;
graph[0] = {1, 3};
graph[1] = {0, 2, 4};
graph[2] = {1};
graph[3] = {0, 4};
graph[4] = {1, 3};









*/