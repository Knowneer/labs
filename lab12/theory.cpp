/*
1.
std::map<Key, Value> — контейнер, который хранит пары (ключ → значение).
Ключ (key) — по нему ищем 
Значение (value) — что лежит “за ключом” 
Для чего: быстро находить/добавлять/удалять по ключу: словарь, справочник, таблица соответствий

В массиве доступ по индексу a[i] (i — число 0..n-1).
В map доступ по ключу (строка, число и т.д.): dict["hello"]
В массиве элементы идут по порядку индексов, а в map элементы идут по порядку ключей (отсортированы).

2.
Внутри std::map обычно реализован как сбалансированное бинарное дерево поиска, чаще всего красно-чёрное дерево.

Красно-чёрное дерево — это дерево, которое автоматически держит “примерно одинаковую высоту”, чтобы не превращаться в “палку”. За счёт этого операции остаются быстрыми.

Красно-чёрное дерево — это самобалансирующееся бинарное дерево поиска.
Именно на нём обычно реализован std::map и std::set.
Бинарное дерево поиска (база)
У каждого узла:
левый потомок — меньше текущего ключа
правый потомок — больше текущего ключа
В красно-чёрном дереве:
каждый узел либо красный, либо чёрный
цвет нужен не для красоты, а чтобы дерево не разваливалось
Основные правила
Корень — чёрный
У красного узла не может быть красных детей
На любом пути от корня до листа — одинаковое количество чёрных узлов



сложность O(log n) для поиска, вставки и удаления элементов

3.

std::unordered_map<Key, Value> — тоже пары (ключ→значение), но внутри хеш-таблица.
Хеш-таблица: ключ прогоняется через хеш-функцию, получается число → по нему выбирается “корзина” (bucket), где лежит элемент.
Хэш-функция — это функция, которая:
берёт ключ - превращает его в число

Плюсы unordered_map:  очень быстрый поиск
Минусы: нет порядка, больше расход памяти


4.
unordered_map, когда:
нужен максимально быстрый поиск
порядок не важен
ключи хешируются нормально (строки/числа — ок)

map, когда:
нужен отсортированный порядок по ключу
нужны операции “по диапазону”: найти всё от "cat" до "dog"

Быстрее для поиска (обычно): unordered_map
Сохраняет порядок: map (по возрастанию ключа)

5.
std::set<T> — контейнер уникальных элементов типа T, хранит их в отсортированном виде
Отличия от vector:

vector хранит всё подряд и допускает повторы, доступ по индексу
set не имеет индексов как v[i] (там итераторы), зато быстрые операции по значению


потому что set — это “множество”, по определению каждый элемент уникален, При попытке вставить повтор — вставка просто не добавит новый элемент

6.	
unordered_set — множество на хеш-таблице (как unordered_map, только без значений).
unordered_set: O(1), нет порядка
set: O(log n), но элементы отсортированы

если
нужен порядок/диапазоны/минимум-максимум — set
нужен просто “есть/нет” быстро — unordered_set


7.
Обычные map/set требуют уникальные ключи/элементы

multimap — ключи могут повторяться
Пример: "apple" -> "яблоко", "apple" -> "эппл (компания)"

multiset — элементы могут повторяться
Пример: хранить оценки: 5,5,4,3,5

когда у одного ключа несколько значений
когда повторы — это нормально и важно сохранить все

8.
1)
dict[key] = value;
если ключа не было — создаст элемент
если был — перезапишет значение
минус: dict[key] создаёт элемент даже если ты просто “проверить хотел” (поэтому осторожно)

2)
dict.insert({key, value});
если ключ уже есть — не перезапишет
обычно возвращает пару {итератор, bool}: bool показывает, вставилось или нет

3)
dict.emplace(key, value);

9.
Через find:
auto it = dict.find(key);
if (it != dict.end()) {  есть  }

Через count (обычно 0 или 1 для map):
if (dict.count(key)) {  есть  }


Итератор — это “указатель-подобный объект”, который показывает на элемент контейнера и позволяет по нему ходить

it->first — ключ
it->second — значение

10.
map
for (const auto& p : dict) {
    std::cout << p.first << " -> " << p.second << "\n";
}

set
for (const auto& x : s) {
    std::cout << x << "\n";
}

map и set выводят в отсортированном порядке (по ключу/значению)



*/