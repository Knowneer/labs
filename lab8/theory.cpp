#include <iostream>


/*
1.
Объявление одномерного массива:

int arr[5];          // 5 целых, индексы 0..4
double a[10];        // 10 double
char name[20];       // 20 символов
Элементы массива лежат подряд, без промежутков:
arr[0], arr[1], arr[2], ... идут в памяти как один непрерывный блок

В памяти по разному лежат
У массива есть один общий идентификатор (arr) и индекс для доступа
У отдельных переменных — каждое имя своё
Массив можно перебрать циклом for, просто двигаясь по индексам

2.
void foo(int arr[], int size); 	
параметр arr — это указатель int*, а не настоящий массив
для компилятора:
void foo(int* arr, int size);

void foo(int arr[], int size) {
    std::cout << sizeof(arr); // будет sizeof(int*) — 8 байт (на 64-битной системе)
}

main:
int arr[10];
std::cout << sizeof(arr);  // 10 * sizeof(int)

правильно:
void printArray(const int* arr, int size);


3.
int a[3][4];  // 3 строки, 4 столбца

Хранится в строках (row-major order).
Сначала элементы a[0][0]..a[0][3], потом a[1][0]..a[1][3], потом a[2][0]..a[2][3].

a[строка][столбец];
a[1][2] = 10;  // 2-й индекс строки, 3-й индекс столбца

либо через цикл
for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < 4; ++j) {
        std::cout << a[i][j] << ' ';
    }
    std::cout << '\n';
}

4.
int arr[10];
arr[100] = 5; // размер 10, индексы 0..9

Это обращение вне границ массива
Компилятор ничего не гарантирует: это undefined behavior
Может упасть программа
Может переписаться чужая память
Может «работать» случайно и потом внезапно ломатьс

Язык не делает автоматических проверок границ обычных массивов для скорости
Как избежать:
Всегда следить, чтобы 0 <= i < size
В std::vector и std::array есть метод .at(i) — он проверяет границы

-fsanitize=address
5.
Bubble sort (пузырьковая)
Идея: многократно проходим по массиву и обмениваем соседние элементы, если стоят в неправильном порядке

void bubbleSort(int* arr, int size) {
    for (int i = 0; i < size - 1; ++i) {
        for (int j = 0; j < size - 1 - i; ++j) {
            if (arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
            }
        }
    }
}


Selection sort (сортировка выбором
Идея: находим минимальный элемент и меняем его с текущей позицией
void selectionSort(int* arr, int size) {
    for (int i = 0; i < size - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < size; ++j) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        std::swap(arr[i], arr[minIndex]);
    }
}

template <typename T>
void mySwap(T& a, T& b) {
    T tmp = a;
    a = b;
    b = tmp;
}


6.
int arr1[5];             // C-массив
std::array<int, 5> arr2; // C++ контейнер

Оба хранят 5 int подряд в памяти 
Отличия std::array:
Знает свой размер: arr2.size()
Можно передавать по значению: копирование, присваивание работает ожидаемо

Плюсы std::array:

Более безопасен
Лучше дружит со стандартной библиотекой
Легче передавать в функции



7.
std::array<int, 5> arr = {1, 2, 3, 4, 5};
for (auto x : arr) {
    // x — КОПИЯ элемента
}
auto x — это копия элемента массива
Цикл автоматически перебирает все элементы массива без индексов и без риска выйти за границы
	Почему удобно:
Не пишем индексы
Нельзя случайно выйти за границы
Код короче и читается проще


Когда нужен auto& x (ссылка):

for (auto& x : arr) {
    x *= 2; // изменяем элементы массива
}


auto& x — ссылка на реальный элемент массива, а не копия

если хотим изменить элементы массива
если элементы большего размера (структуры и т.п.), чтобы не копировать


8.
#include <fstream>
#include <string>

открытие файла для чтения:
std::ifstream in("input.txt");
if (!in.is_open()) {
    // ошибка открытия
}



открытие файла для записи:
std::ofstream out("output.txt");
if (!out.is_open()) {
    // ошибка открытия
}

Чтение по словам / числам (по элементам):
int x;
while (in >> x) {
    // читаем числа, пока удаётся
}

чтение построчно:
std::string line;
while (std::getline(in, line)) {
    // line — очередная строка файла
}

9.
int arr1[5];       // размер 5, известен на этапе компиляции
int n;
// ...
int* arr2 = new int[n]; // динамический массив

Статический массив (на стеке):
Размер должен быть известен (в стандарте) на этапе компиляции.
Автоматически уничтожается при выходе из функции.
Динамический массив (new):
Размер можно узнать в рантайме (во время выполнения программы)
Память выделяется в куче (heap).
Нужно явно освобождать:)

delete[] arr2;  // обязательно квадратные скобки для массива
Почему нельзя просто delete?
new[] / delete[] — пара
new / delete — другая пара
Если перепутать — undefined behavior: память может утечь, могут не вызваться деструкторы и т.дю



10.
std::vector<int> — динамический массив из стандартной библиотеки

#include <vector>
std::vector<int> v;         // пустой вектор
std::vector<int> v2(10);    // 10 элементов, инициализированы нулями
std::vector<int> v3 = {1, 2, 3};


Основные методы:
v.size() — текущий размер
v.empty() — пустой или нет
v.push_back(x) — добавить элемент в конец
v.pop_back() — удалить элемент с конца
v.clear() — удалить все элементы
v.front(), v.back() — первый и последний элемент
Почему удобнее, чем new + delete[]:
Сам управляет памятью (не надо думать о delete[])
Можно менять размер (push_back, resize)
Много полезных методов

11.
Псевдоним типа — новое имя для уже существующего типа.
using IntVec = std::vector<int>;
using ll = long long;
IntVec a;        // то же, что std::vector<int> a;
ll x = 123456;   // то же, что long long x;

Зачем:
Сократить длинные типы:
using StudentsMap = std::map<std::string, std::vector<int>>;
Сделать код читабельнее: по имени видно смысл.
Упростить поддержку: поменял тип в одном месте — он сменился везде.


12.
Проверка открытия:
std::ifstream in("input.txt");
if (!in.is_open()) {
    std::cerr << "Ошибка: не удалось открыть файл input.txt\n";
    // обработать ошибку: выйти из функции, вернуть код ошибки и т.д.
}

Проверка конца файла и ошибок чтения:
int x;
while (in >> x) {
    // здесь мы входим ТОЛЬКО если чтение прошло успешно
}

Если файл закончился или формат неправильный → in >> x вернёт false, цикл закончится.
if (in.fail() && !in.eof()) {
    std::cerr << "Ошибка чтения (не тот формат данных?)\n";
}

fail
Возвращает true, если произошла ошибка чтения данных:
файл недоступен
файл повреждён
попытались читать дальше конца файла

Если произошла ошибка (fail == true)
но это НЕ конец файла (!eof)
значит, это ошибка формата или данных → выдать сообщение об ошибке

*/


int main() {

		return 0;
}