/*

1.
Структура (struct) — это пользовательский тип данных, в котором можно объединить несколько полей разных типов

Структура	
Хранит разные типы: int + string + char…	
Описывает один “объект”
Поля имеют имена

Массив
Хранит элементы одного типа
Хранит набор однотипных объектов
Доступ по индексам

struct Song {
    char* title;
    char* artist;
    int duration;
};
Song s;
s.title = "Imagine";
s.artist = "John Lennon";
s.duration = 183;
Song playlist[10]; // массив из 10 песен


2.

Компилятор кладёт поля по порядку
Коме байты (padding) между полями
Между полями добавляются “пустые” байты, чтобы int лежал по адресу, кратпилятор может добавлять дополнительныному 4

Размер структуры может быть больше суммы размеров всех её полей из-за добавленного выравнивания (padding)

3.
Битовые поля — это способ экономить память, когда нужно хранить несколько логических (булевых) значений или
небольших чисел в пределах одного байта или слова.
Они объявляются с указанием количества битов после двоеточия.
struct Flags {
    unsigned int isPlaying : 1; // 1 бит
    unsigned int volume    : 7; // 7 бит
    unsigned int mode      : 2; // 2 бита
};
использование:
флаги ("вкл/выкл");

4.

Односвязный список — это структура данных, состоящая из узлов, где каждый узел содержит данные и указатель на 
следующий узел в списке. В отличие от массива, элементы односвязного списка не хранятся в смежных ячейках памяти, 
а связаны между собой через указатели.
Преимущества односвязного списка:
- Динамическое выделение памяти: размер списка может изменяться во время выполнения программы.
не нужно выделять большой кусок памяти сразу
Недостатки односвязного списка:
- Медленный доступ по индексу: для доступа к элементу по индексу требуется
	проход по списку от начала до нужного узла, что занимает линейное время.

5.
Узел — структура с двумя полями:

struct Node {
    Song data;  // сама песня
    Node* next; // указатель на следующий узел
};


next — это адрес следующего узла.
Если next = nullptr → конец списка.

6. 
добавление в начало 
newNode->next = head;
head = newNode;

добавление в конец 
Node* cur = head;
while (cur->next != nullptr)
    cur = cur->next;

cur->next = newNode;
newNode->next = nullptr;

середина(после prev)
newNode->next = prev->next;	
prev->next = newNode;		


7.
удалить в начале
Node* temp = head;
head = head->next;
delete temp;


из конца
Node* cur = head;
while (cur->next->next != nullptr) 
    cur = cur->next;

delete cur->next;
cur->next = nullptr;

из середины (после prev)
prev->next = cur->next;
delete cur;

если не вызывать delete → утечка памяти (memory leak) — память не освобождается.


8.
Node* cur = head;
while (cur != nullptr) {
    // обработка узла
    cur = cur->next;
}
head — указатель на первый элемент списка


9.

Node* cur = head;
while (cur != nullptr) {
    if (cur->data.title == name) return cur;
    cur = cur->next;
}
Почему медленно:
нет прямого доступа list[5]
Нужно пройти через указатели

в массиве просто по индексу

10.
если сделать delete head
то удалится только первый узел,
остальные узлы останутся в памяти, что приведёт к утечке памяти (memory leak)

правильно
Node* cur = head;
while (cur != nullptr) {
    Node* temp = cur;
    cur = cur->next;
    delete temp;
}
head = nullptr;



11.

Это стандартный односвязный список из STL.
Под капотом — примерно то же самое, что ты пишешь в лабе.Методы:

push_front()  	// добавить в начало
pop_front()  	// удалить первый элемент
insert_after() 		// вставить после указанного элемента
erase_after()  	// удалить элемент после указанного
remove()				// удалить все элементы с заданным значением
clear()			// очистить список	


отличия между std::forward_list и односвязным списком:
- std::forward_list имеет множество встроенных методов для удобной работы со списком
- std::forward_list управляет памятью автоматически, что снижает риск утечек памяти


12.
Какие ещё структуры данных существуют кроме массивов и списков?
vector
stack

двусвязный список
struct Node {
    int data;
    Node* next;
    Node* prev;
};
односвязный список:
	только вперед
	хорошая скорость вставки/удаления
	низкое потребление памяти

двусвязный список:
	вперед и назад
	сложнее реализовать
	больше памяти из-за указателя prev

*/	