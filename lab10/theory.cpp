/*
1.
Строка в C++ — это последовательность символов

char str[] = "Hello";   // C-строка
Это массив char, который обязательно заканчивается '\0'

плюсы
Простая структура

минусы
Нужно самостоятельно управлять памятью
Нужно следить за '\0'

std::string s = "Hello"; // C++ строка

Это класс стандартной библиотеки, который сам управляет памятью

плюсы
Удобный интерфейс
Автоматическое управление памятью
минусы
Немного больше накладных расходов по памяти и времени на управление памятью
накладные расходы Это дополнительные ресурсы (память, время), которые требуются для выполнения задачи, но не являются частью самой задачи


2.
'\0' — нулевой символ, конец C-строки
По нему функции понимают, где строка заканчивается

если забыть за него
strlen, printf, strcpy пойдут читать мусор в памяти
Возможен краш программы

всегда +1 к размеру массива для '\0'

3.
ASCII (American Standard Code for Information Interchange) — это таблица кодов символов, где каждому символу соответствует число от 0 до 127
Использует 1 байт
Всего 128 символов
Включает:
латинские буквы A–Z, a–z
цифры 0–9
знаки пунктуации
управляющие символы (\n, \t, \0)

Unicode — это универсальный стандарт кодирования символов, который описывает все символы всех языков мира.
Каждому символу сопоставляется уникальный код (code point)

UTF-8 — это способ кодирования Unicode-символов в байты.

Особенности UTF-8:
Переменная длина
Совместим с ASCII
Использует от 1 до 4 байт

русские буквы больше потому что 
UTF-8 сохраняет совместимость с ASCII
Все коды выше 127 кодируются несколькими байтами
Кириллица находится вне диапазона ASCII

Использовать UTF-8 кодировку исходников
std::string.length() // считает байты а не символы


4.
#include <cstring>
Основные функции:

strlen — длина
strcpy / strncpy — копирование
strcat — конкатенация
strcmp — сравнение
strchr — поиск символа
Почему опасны?
Не проверяют размер буфера
Легко вызвать переполнение памяти

5.
char s[6] = "Hello";
char s[] = "Hello";
char s[6] = {'H','e','l','l','o','\0'};

char str[10]
Это массив из 10 символов
Память выделена сразу (обычно на стеке)
Можно менять содержимое: str[0] = 'A';


char* str
Это указатель на char
Сам по себе память под символы не выделяет
Он просто хранит адрес, куда указывает

Строковый литерал — это текст в кавычках:
"Hello"
Он хранится в памяти как готовый массив символов с '\0'
строковый литерал имеет тип const char[N]
менять его нельзя

6.
length() и size()
Обычно одно и то же:
std::string s = "abc";
s.size();   // 3
s.length(); // 3

c_str() — получить C-строку из std::string с '\0' на концe
Нужно, когда функция принимает const char*


substr(pos, len) — получить подстроку
std::string s = "Hello world";
auto a = s.substr(0, 5); // "Hello"

find()
Ищет подстроку/символ. Если не найдено — std::string::npos
auto pos = s.find("world");
if (pos != std::string::npos) {  найдено  }
std::string::npos — это специальная константа, которая означает
 «ничего не найдено» при работе со строками


append()
Добавляет к текущей строке:
s.append("!!!");

+ vs append()
s = s + "!";
s.append("!");

+ часто создаёт новую строку (лишние копии)
append() меняет текущую, обычно эффективнее

7.
c- string
const char* c = "Hello";
std::string s = c;

string - c 
std::string s = "Hello";
const char* c = s.c_str();

c_str() возвращает указатель на внутренний C-массив, который:
содержит '\0'
имеет тип const char*

когда надо
Многие функции принимают только const char*

8.
cin >> s
читает до пробела
удобно для “одного слова”


getline(cin, s)
читает всю строку, включая пробелы

gets()
не знает размер буфера → переполнение       // зачем оставили в стандарте C11?
не использовать!

9.
const char* src = "Hello";
int len = std::strlen(src);

char* s = new char[len + 1]; // +1 под '\0'
std::strcpy(s, src);

delete[] s;

10.
Конкатенация
std::string: +, append
C-строки: strcat (опасно, если мало места)

Сравнение
std::string:
if (a == b) {}


C-строки:
if (std::strcmp(a, b) == 0) {}

Почему нельзя == для C-строк?
Потому что сравниваются адреса, а не символы:
char a[] = "hi";
char b[] = "hi";
(a == b) // false, это разные массивы в памяти


11.
Токенизация — разбиение строки на части (токены) по разделителю
C-строки: strtok
char s[] = "a,b,c";
char* tok = std::strtok(s, ",");
while (tok) {
    // tok — очередной кусок
    tok = std::strtok(nullptr, ",");
}
trtok портит исходную строку (ставит '\0' вместо разделителей).

std::string: find + substr



12.
строка → число

atoi("123") (старый C-вариант):
если строка плохая → часто вернёт 0 (непонятно, ошибка или реально 0)

stoi("123") (C++):
если строка некорректная → выбросит исключение

std::invalid_argument — если вообще не число
std::out_of_range — если слишком большое число









EXTRA TASK
char* makeWord(const char* src) {
    char* w = new char[strlen(src)];        // ошибка: нет места под '\0'
    strcpy(w, src);     // краш из за неправильно выделенной памяти 
    return w;               
}


int main(){
char text[] = "Hello world";
char* p = strstr(text, "world");    // не выделяет память

if (p != nullptr)
    cout << p << endl;      // без std 

delete[] p;         // ошибка: память не выделялась через new, нельзя удалять
return 0;           // undefined behavior / краш / corruption памяти
}

*/
