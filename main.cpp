#include "employee.hpp"
#include <iostream>
#include <vector>

using namespace lab6;
    
/*
1.
Code segment (текст)	машинные инструкции программы ( скомпилированный код)	только для чтения
.data	глобальные и статические переменные с инициализацией	существует всё время работы программы
.bss	глобальные и статические переменные без инициализации	автоматически заполнены нулями
Stack (стек)	локальные переменные, параметры функций, адрес возврата	выделяется автоматически при вызове функции
 и освобождается при выходе из неё

 int global_init = 10;   // .data
int global_uninit;      // .bss

void foo() {
    int local = 5;      // stack
}

 2.Heap (куча) — область памяти, где переменные создаются во время выполнения программы через new
В отличие от стека, она освобождается ne автоматически, а только вручну.
компилятор не знает, когда объект тебе больше не нужен.
Если забыть вызвать delete → память останется занята → утечка памяти (memory leak).

3. память —  огромный массив байт, где у каждой ячейки есть адрес (0, 1, 2, 3…)

Если переменная int a = 10; — то где-то в памяти (например, с адреса 1000) лежат 4 байта с числом 10.
 У каждой переменной есть адрес.

Указатель (pointer) — это переменная, которая хранит адрес другой переменной.
int a = 42;
int* p = &a;  // p хранит адрес a
a — просто число 42

&a — адрес переменной a

p — указатель, который хранит этот адрес

*p — доступ к самому значению (42)


4.
Разыменование	*ptr	доступ к значению по адресу
Получение адреса	&var	получить адрес переменной
Арифметика указателей	ptr++, ptr + n	двигает указатель на n элементов (но не байт)
Разница указателей	ptr2 - ptr1	сколько элементов между ними
Сравнение	ptr1 == ptr2, <, >	сравнивает адреса в памяти
--ptr возможно

5. int* p = new int;     // выделили место под 1 int в куче
*p = 10;              // записали значение
delete p;             // освободили память

поэтому new и delete медленнее, чем просто int x;,
потому что в стеке всё выделяется мгновенно.

6.memory leak - когда выделил память через new, но забыл вызвать delete

каждый new должен иметь соответствующий delete

если программа выделяет память в цикле, но не освобождает её — память будет расти,
и в конце концов программа может упасть из-за нехватки памяти


7.UB (неопределённое поведение) — это когда ты делаешь что-то, что C++ не может предсказать

int* p = nullptr;
*p = 5;        // UB — обращение к нулевому указателю

double free — это когда память освобождают дважды:

int* p = new int(10);
delete p;
delete p;  //  ошибка: память уже удалена

программа падает, виснет


8. g++ -fsanitize=address -fno-omit-frame-pointer -g main.cpp -o main
./main

-fsanitize=address — включает проверку памяти

-fno-omit-frame-pointer — улучшает отчёт

-g — добавляет отладочную информацию
AddressSanitizer (ASan) — это специальный инструмент, который включается
при компиляции программы, чтобы автоматически находить ошибки работы с памятью.


9.reinterpret_cast - жесткое приведение типов между указателями или числами. Меняет способ интерпретации бит
int a = 65;
char* p = reinterpret_cast<char*>(&a);
std::cout << *p; // выведет символ 'A'
char забирает лишние биты в памяти(чужие)

Оно не меняет данные, а просто смотрит на ту же память по-другому.
Опасно, потому что легко нарушить выравнивание или типы.

10.Объявление |	Что нельзя менять	| Что можно менять	| Пример
const int* ptr	значение (данные)	сам адрес	нельзя *ptr = ..., но можно ptr++
int* const ptr	адрес	значение	нельзя ptr = ..., но можно *ptr = ...
const int* const ptr	и адрес, и значение	ничего	полностью постоянный


int x = 5, y = 10;

// 1 указатель на константу (нельзя менять данные)
const int* p1 = &x;
p1 = &y;   // можно
//*p1 = 7; // нельзя

// 2 константный указатель (нельзя менять адрес)
int* const p2 = &x;
*p2 = 8;   // можно
//p2 = &y; // нельзя

// 3 константный указатель на константу
const int* const p3 = &x;
//p3 = &y;  // нельзя
//*p3 = 9;  // нельзя


*/

int main()
{

    // создаём несколько сотрудников
    Employee *e1 = create_employee("Иван", 30, 50000.0f);
    Employee *e2 = create_employee("Мария", 25, 60000.0f);
    Employee *e3 = create_employee("Антон", 40, 80000.0f);

    if (!e1 || !e2 || !e3)
    {
        std::cerr << "Ошибка создания сотрудников\n";
        return 1;
    }

    std::cout << "=== Сотрудники ===\n";
    print_employee(e1);
    print_employee(e2);
    print_employee(e3);

    // выдаём зарплату Ивану
    give_salary(e1, 5000.0f);
    std::cout << "\nПосле премии:\n";
    print_employee(e1);

    // сравниваем возраст
    int res = 0;
    compare_age(e1, e2, &res);
    if (res > 0)
        std::cout << e1->name << " старше, чем " << e2->name << "\n";
    else if (res < 0)
        std::cout << e1->name << " младше, чем " << e2->name << "\n";
    else
        std::cout << "Они ровесники\n";

    // создаём массив указателей
    std::vector<Employee *> employees = {e1, e2, e3};

    std::cout << "\n=== Все сотрудники после изменений ===\n";
    for (const Employee *e : employees)
        print_employee(e);

    // освобождаем память
    for (Employee *e : employees)
        delete_employee(e);

    return 0;
}
